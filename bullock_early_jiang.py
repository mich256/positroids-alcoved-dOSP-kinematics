

# This file was *autogenerated* from the file bullock-early-jiang.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
def hDOSP(n,k):
	temp = []
	for c2 in Compositions(n,min_part=_sage_const_2 ):
		for osp in OrderedSetPartitions(n,c2):
			if _sage_const_1  in osp[_sage_const_0 ]:
				for c in Compositions(k,inner=[_sage_const_1 ]*len(osp), outer=[len(i) for i in osp]):
					temp.append((osp,tuple(c)))
	return temp

def hDOSP_pp(pair):
	return ', '.join(str(set(pair[_sage_const_0 ][i]))+str(str(pair[_sage_const_1 ][i])) for i in range(len(pair[_sage_const_1 ])))

def J_Sr(J,n):
	S = []
	r = []
	m = min(i for i in range(_sage_const_1 ,n+_sage_const_1 ) if i not in J)
	i = m
	t1 = set()
	t2 = _sage_const_0 
	t = _sage_const_0 
	while i < n+_sage_const_1 :
		if i in J:
			t2 += _sage_const_1 
			t = _sage_const_1 
		if i not in J:
			if t == _sage_const_1 :
				S.append(t1)
				t1 = set()
				r.append(t2)
				t2 = _sage_const_0 
				t = _sage_const_0 
		t1.add(i)
		i += _sage_const_1 
	t1.update(range(_sage_const_1 ,m))
	S.append(t1)
	r.append(t2)
	return (OrderedSetPartition(S),tuple(r))

def sJ_XSr(Sr,J):
	return max([sum(Sr[_sage_const_1 ][:j]) - sum(len(J.intersection(Set(Sr[_sage_const_0 ][i]))) for i in range(j)) for j in range(len(Sr[_sage_const_0 ]))])

def XSr(Sr):
	n = Sr[_sage_const_0 ].base_set_cardinality()
	k = sum(Sr[_sage_const_1 ])
	return {J: sJ_XSr(Sr,J) for J in Subsets(n,k)}

def sJ(J,n):
	temp = dict()
	k = len(J)
	IJ = set([j for j in range(_sage_const_1 ,n+_sage_const_1 ) if j in J and j-_sage_const_1  not in J])
	if _sage_const_1  in J and n not in J:
		IJ.add(_sage_const_1 )
	for M in Subsets(IJ):
		JJ = set()
		for j in range(_sage_const_1 ,n+_sage_const_1 ):
			if j in (J-M):
				JJ.add(j)
			if j in (J&M):
				if j != _sage_const_1 :
					JJ.add(j-_sage_const_1 )
				else:
					JJ.add(n)
		temp[frozenset(JJ)] = (-_sage_const_1 )**(len(J.intersection(M))-k-_sage_const_1 )
	return temp

def XJ_XSr(Sr,J):
	n = Sr[_sage_const_0 ].base_set_cardinality()
	k = sum(Sr[_sage_const_1 ])
	IJ = set([j for j in range(_sage_const_1 ,n) if j in J and j+_sage_const_1  not in J])
	temp = _sage_const_0 
	if n in J and _sage_const_1  not in J:
		IJ.add(n)
	for M in Subsets(IJ):
		JJ = set()
		for j in range(_sage_const_1 ,n+_sage_const_1 ):
			if j in J.difference(M):
				JJ.add(j)
			if j in J.intersection(M):
				if j != n:
					JJ.add(j+_sage_const_1 )
				else:
					JJ.add(_sage_const_1 )
		# tt = (-1)^(len(J.intersection(M))-k-1)*sJ_XSr(Sr,JJ)
		# print(JJ,tt)
		temp += (-_sage_const_1 )**(len(J.intersection(M))-k-_sage_const_1 )*sJ_XSr(Sr,JJ)
		#temp += tt
	return temp

def main(n,k):
	for Sr in hDOSP(n,k):
		d = XSr(Sr)
		print(hDOSP_pp(Sr))
		print({J: XJ_XSr(Sr,J) for J in Subsets(n,k)},'\n')

# if __name__ == '__main__':
# 	import sys
# 	main(*map(int, sys.argv[1:]))

